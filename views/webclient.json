{"id":"webclient","title":"Web Client","html":"<p></p>  \n<p>Sitebricks provides a really simple and effective API for writing HTTP clients in Java. It supports writing in both synchronous and asynchronous (non-blocking) styles. The latter form can be extremely useful for high-performance IO. Scroll down to see examples of the Sitebricks Async web client. Here is an example of fetching the Google home page:</p> \n<pre><code>Web web = Guice.createInjector().getInstance(Web.class);\n\nWebResponse response = web.clientOf(&quot;http://google.com&quot;)\n    .transportsText()\n    .get();\n\nSystem.out.println(response.toString());\n</code></pre> \n<p>To add this library to your Maven project, add the following dependency:</p> \n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.google.sitebricks&lt;/groupId&gt;\n  &lt;artifactId&gt;sitebricks-client&lt;/artifactId&gt;\n  &lt;version&gt;0.8.7-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> \n<h3>Fetching resources</h3> \n<p>Sitebricks Client supports the common set of HTTP methods. To send a post, use the following code:</p> \n<pre><code>WebResponse response = web.clientOf(&quot;http://google.com&quot;)\n    .transports(String.class)\n    .over(Text.class)\n    .post(&quot;q=sitebricks&quot;);\n</code></pre> \n<p>Here I've posted a string containing <code>q=sitebricks</code> to the Google search page. This code can also be written more succinctly if only transporting strings:</p> \n<pre><code>WebResponse response = web.clientOf(&quot;http://google.com&quot;)\n    .transportsText()\n    .post(&quot;q=sitebricks&quot;);\n</code></pre> \n<p>Using the various transports you can post other kinds of data (like JSON or XML) marshalled from simple Java objects. Reading the response back is similarly trivial:</p> \n<pre><code> String url = &quot;http://api.twitter.com/version/statuses/public_timeline.json&quot;;\n WebResponse response = web.clientOf(url)\n     .transportsText()\n     .get();\n\n Tweets tweets = response.to(Tweets.class).using(Json.class);\n //...\n</code></pre> \n<p>In this example, I fetch the Twitter public timeline in JSON format. An existing Java class named <code>Tweets</code> is populated with the data from Twitter's JSON feed. The class <code>Json</code> is a Sitebricks <code>Transport</code> and is bundled with the library. Sitebricks also bundles XML and Raw (byte-buffer) transports.</p> \n<ul> \n <li>Json.class - Backed by Jackson JSON library</li> \n <li>Xml.class - Backed by XStream XML parsing library</li> \n <li>Text.class - Simple <code>toString()</code></li> \n <li>Raw.class - Uses a byte-buffer to send data such as binary files</li> \n</ul> \n<p>You can similarly add</p> \n<h3>Advanced</h3> \n<p>Sitebricks Client is powered by AHC web client and Netty and is designed to be fast and performant, in addition to being simple and type-safe.</p> \n<h3>Asynchronous (Non-blocking) IO</h3> \n<p>Using non-blocking IO, Sitebricks can fetch resources in the background freeing up user threads to do other important tasks. The fetching is performed at the hardware level and thus CPU threads do not block while resources are being up- or down- loaded.</p> \n<pre><code>ExecutorService executor = Executors.newSingleThreadExecutor();\nListenableFuture&lt;WebResponse&gt; future = web.clientOf(&quot;http://sitebricks.org&quot;)\n    .transportsText()\n    .get(executor);\n\nString response = future.get().toString();\n</code></pre> \n<p>Notice that in this example, we pass in a threadpool (in the form of an <code>executor</code>) to the <code>get()</code> method. When the request completes, Sitebricks will populate the future with the server's response. A future in this case is a <em>promise</em> to return the value at some point in the future. If you call <code>future.get()</code> as we have done in the above example, the current thread will block until the promise is fulfilled. Here, the IO is happening asynchronously, but we're still blocking the current thread until it completes by waiting on the future.</p> \n<p>Instead, you may elect to be notified when the IO completes by adding a listener:</p> \n<pre><code>ExecutorService executor = Executors.newSingleThreadExecutor();\nListenableFuture&lt;WebResponse&gt; future = web.clientOf(&quot;http://sitebricks.org&quot;)\n    .transportsText()\n    .get(executor);\n\nfuture.addListener(new Runnable() {\n  public void run() {\n    String response = future.get().toString();\n  }\n}, executor);\n</code></pre> \n<p>In this example the current thread will return immediately and be available for performing other tasks. When the response arrives, Sitebricks will call your listener on a thread backed by the provided executor. Inside this listener, calling <code>future.get()</code> is guaranteed not to block.</p>","postedOn":"01 Oct 2012"}